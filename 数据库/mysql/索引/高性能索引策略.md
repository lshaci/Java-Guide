### 独立的列
索引列不能是表达式的一部分,也不能是函数的参数

下面这个无法使用索引
```angular2html
select name from table where name+1=5;
```
### 前缀索引和索引选择性
需要索引很长的字符列,会让索引变得大且慢

要点:
```angular2html
1.前缀索引不能太长
2.需要索引的列的前缀值有较高的选择性(多样性)
```
缺点:
```angular2html
无法做order by和group by
```

### 多列索引
- 当服务器对多个索引做相交操作时(多个and条件),需要一个包含所有相关列的多列索引,而不是多个独立的单独索引
- 当服务器需要对多个索引做联合操作时(多个or),如果不用多列索引,性能很低

### 合适的索引列顺序
建立多列索引的原则:将选择性最高的列放在前面(不考虑排序和分组,排序和分组最好能利用多列索引的顺序)

### 聚簇索引
聚簇索引是指将数据行与索引放在一起

在InnoDB中,聚簇索引是叶子叶包含了行的全部数据和索引列(主键),节点页只包含索引列

但是二级索引(非聚簇索引)访问需要两次索引查询,因为二级索引的叶子节点只包含了引用行的主键

尽量避免随机的聚簇索引,如用uuid做主键

### 覆盖索引
覆盖索引是指一个索引覆盖所有需要查询的字段的值

优点:
```angular2html
1.索引条目远小于数据行大小,因为只需要读取索引,极大的减少数据访问梁
2.索引按照列值顺序存储，对于I/O密集的范围查询会比随机从磁盘中读取每一行数据的I/O要少很多。
3.InnoDB的辅助索引（亦称二级索引）在叶子节点中保存了行的主键值，如果二级索引能够覆盖查询，则可不必对主键索引进行二次查询了。
```
覆盖索引就是从索引中直接获取查询结果，要使用覆盖索引需要注意select查询列中包含在索引列中；where条件包含索引列或者复合索引的前导列；查询结果的字段长度尽可能少。

如果不是,那就需要扫描一条索引记录就得回表查询一次对应的行

### 使用索引扫描做排序
- 只有当索引的列顺序和order by的顺序完全一致,并且所有列的排序方向(倒序或正序)都一样,mysql才能够使用索引来对结果做排序
- 如果需要关联多张表时,则只有当order by引用的字段全部为第一张表时,才能使用索引做排序
- order by需要满足索引的最左前缀的要求,除非前导列是个常量
  