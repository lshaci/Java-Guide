##### 概述
XA/JTA

XA 就是 X/Open DTP 定义的事务管理器与资源管理器的接口规范（即接口函数），XA 接口函数由数据库厂商提供

JTA是基于X/Open DTP模型开发的java transaction APi规范

通过2pc的方式去完成分布式事务，虽然通过这种方式能够达到预期的效果，
但是我们在现实中很少会用到2pc方式的提交的XA事务，有几个原因
- 1.互联网电商应用的快速发展，对事务和数据的绝对一致性要求并没有传统企业应用那么高
- 2.XA事务的介入增加了TM中间件，使得系统复杂化
- 3.XA事务的性能不高，因为TM要等待RM回应，所以为了确保事务尽量成功提交，
等待超时的时间通常比较长，比如30s到几分钟，如果RM出现故障或者响应比较慢，则整个事务的性能严重下降

##### 互联网的分布式事务解决方案
目前互联网领域里有几种流行的分布式解决方案，但都没有像之前所说的XA事务一样形成X/OpenDTP那样的工业规范，
而是仅仅在具体的行业里获得较多的认可

最终一致性方案之ebay模式

eBay在2008年公布了一个关于BASE准则提到一个分布式事务解决方案。eBay的方案其实是一个最终一致性方案，
它主要采用消息队列来辅助实现事务控制流程，方案的核心是将需要分布式处理的任务通过消息队列的方式来异步执行，
如果事务失败，则可以发起人工重试的纠正流程。人工重试被更多的应用于支付场景，通过对账系统对事后问题进行处理

比如一个很常见的场景：某个用户产生了一笔交易，那么需要在交易表中增加记录，同时需要修改用户表的金额（余额），
由于这两个表属于不同的远程服务，所以就会涉及到分布式事务与数据一致性的问题

那么在这里可以使用消息队列（MQ）来做

先启动一个事务，更新交易表（transaction）后，并不直接更新user表，而是将要对user表进行的更新插入到消息队列中。
目标系统收到该消息以后，启动本地事务去对用户表的余额做调整

伪代码
```
bool result=dao.update();
if(result){
  mq.send();
}
```
根据上面的伪代码的实现方案，可能出现几种情况
- 数据库操作成功，向MQ中投递消息也成功
- 操作数据库失败，不会向MQ中投递消息
- 操作数据库成功，但是向MQ中投递消息时失败，向外抛出异常。数据库操作回滚

对于上面几种情况，问题都不大。那么我们分析小消费端的问题

- 1.消息出队列以后，消费者对应的业务操作要执行成功。
如果执行失败，消息不能失效或者丢失。需要保证消息和业务操作一致
- 尽量避免消息重复消费，如果重复消费，也不能影响业务的执行结果

对于第一个问题，如何保证消息不丢失

现在用的比较普遍的MQ都具有持久化消息的功能，如果消费者宕机或者消费失败，都可以执行重试机制

对于如何避免消息的重复消费

- 保证消费者的幂等性；也就是说如果队列中的消息因为网络异常导致发送多次的情况下，仍然需要保证消息被应用多次与应用一次产生的效果是一样的
- 通过消费日志表来记录消费状态；增加一个message_applied（msg_id）表，用来记录已经被成功应用的消息。在目标系统执行更新操作之前，先检测该消息是否已经被消费过，消费完成后通过本地事务控制来更新这个“消费表状态”，用来避免消息重复消费问题

上面这种方式是非常经典的实现，基本避免了分布式事务，实现了“最终一致性”。
各大知名的电商平台和互联网公司，几乎都是采用类似的设计思路来实现“最终一致性”的。这种方式适合的业务场景广泛，而且比较可靠。不过这种方式技术实现的难度比较大




